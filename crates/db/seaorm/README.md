# emixseaorm

`emixseaorm` mirrors the repository abstractions from the Diesel crate while
speaking SeaORM. It keeps filtering, pagination, and relationship handling
consistent across database backends.

## Feature Flags

- `sqlite`, `postgres`, `mysql`: Pick your database driver.
- `mariadb`: Alias for the MySQL stack.
- `full`: Enable every supported backend.

```toml
[dependencies]
emixseaorm = { path = "../../crates/db/seaorm", features = ["sqlite"] }
```

## Quick Example

```rust
use emixseaorm::prelude::*;
use emixseaorm::repositories::{ClosureFilter, TFilterCondition};
use sea_orm::{Condition, EntityTrait};
use entity::posts; // generated by sea-orm-cli

let filter = ClosureFilter::new(|| Condition::all().add(posts::Column::Published.eq(true)));

let query = filter.apply(posts::Entity::find());
let published = query.all(&db).await?;
```

- Combine `TFilterCondition` and `TFilterRelatedCondition` to express joins.
- Leverage `TRepository` and `TRepositoryWithRelated` to share CRUD logic across
  entities.
- Reuse `emixdb::dto::{Pagination, ResultSet}` for consistent API responses.
- Check the `examples/` directory for a runnable SeaORM + migration showcase.


